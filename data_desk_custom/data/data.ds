/* --- CONSTANTS --- */

MAX_ENTITIES_PER_CHUNK :: 256
MAX_ACTIVE_ENTITIES :: 1024
MAX_OVERLAPPING_COLLIDERS :: 50
MAX_ENTITY_REFERENCES :: 10
MAX_SUB_COLLIDERS :: 3
MAX_STORAGE_SIZE :: 30
MAX_PARTICLE_AMOUNT :: 300
MAX_WORLD_CHUNKS :: 128
CHUNK_SIZE :: 256
CELL_CHUNK_SIZE :: 128
MAX_PIXEL_CLUSTER_LENGTH :: 64
MAX_DYNAMIC_CELLS :: 256


/* --- ENUMS --- */

GeneralisedEntityType :: enum
{
    undefined,
	character,
	monster,
	animal,
	item,
	storage,
	resource,
	scenic,
	ground,
	pixel_object,
}

CellMaterialType :: enum
{
	air,
	dirt,
	sand,
	water,
}


/* --- FLAGS --- */

EntityFlags :: flags
{
	no_delete,
}

ColliderFlags :: flags
{
	ground,
	player,
	entity,
	item,
	trigger,
}

AnimationFlags :: flags
{
	playing,
	reversing,
	repeat,
}

ParticleEmitterFlags :: flags
{
	repeat,
}

PixelFlags :: flags
{
	apply_gravity,
}

CellFlags :: flags
{
	no_gravity,
}

@ForwardDeclare(Entity)
ForwardEntity :: _;


/* --- COMPONENTS --- */

@Component
Position :: struct
{
	position : v2;
}

@Component
Sprite :: struct
{
	sprite_data : SpriteData;
	@Editable
	is_flipped : b8;
	is_background_sprite : b8; // Temp solution
}

@Component
SubSprite :: struct
{
	sub_sprites : SpriteData[MAX_SUB_SPRITES];
	sub_sprite_count : i32;
	is_flipped : b8;
}

@Component
Animation :: struct
{
	flags : AnimationFlags;
	current_frame : i32;
	interval_mult : f32;
	frame_start_time : f32;
}

c2Shape :: union
{
	aabb : c2AABB;
	capsule : c2Capsule;
	circle : c2Circle;
	poly : c2Poly;
}

c2ShapeType :: enum
{
	aabb,
	capsule,
	circle,
	poly,
}

PhysicsMaterial :: struct
{
	density : f32;
	restitution : f32;
}

MassData :: struct
{
	mass : f32;
	inv_mass : f32;
}

@Component
PhysicsBody :: struct
{
	shape : c2Shape;
	shape_type : c2ShapeType;
	material : PhysicsMaterial;
	mass_data : MassData;
	velocity : v2;
	force : v2;
	gravity_multiplier : f32;
}

/*@Component
Collider :: struct
{
	shape : c2Shape;
	shape_type : c2ShapeType;
	
	flags : ColliderFlags;
}

@Component
Velocity :: struct
{
	velocity : v2;
	ideal_velocity : v2;
	acceleration : v2; // You'd have this be dynamic depending on the alpha of the ideal/current velocity to have a multi-phased acceleration function.
	acceleration_mult : v2;
	previous_friction : f32;
	collide_against : b8;
}

@Component
Physics :: struct
{
	restitution : f32;
	mass : f32;
}*/

@Component
Movement :: struct
{
	axis_x : f32;
	move_speed : f32;
	move_speed_mult : f32;
}

@Component
ArcEntity :: struct
{
	entity_type : ArcEntityType;
	current_general_state : *char;
	current_animation_state : AnimationStateType;
}

@Component
Item :: struct
{
	item_type : ItemType;
	stack_size : i32;
}

@Component
Trigger :: struct
{
	enter_trigger_callback : TriggerCallback;
	exit_trigger_callback : TriggerCallback;
	previous_overlaps : OverlappedColliderInfo[MAX_OVERLAPPING_COLLIDERS];
	previous_overlaps_count : i32;
	trigger_against : b8;
}

@Component
Storage :: struct
{
	storage_size : i32;
	items : *ItemComponent[MAX_STORAGE_SIZE];
}

@Component
Parallax :: struct
{
	parallax_amount : v2;
	desired_position : v2;
}

@Component
ParticleEmitter :: struct
{
	life_time : f32;
	start_time : f32;
	flags : ParticleEmitterFlags;
	particles : Particle[MAX_PARTICLE_AMOUNT]; // Need to put this somewhere else?
	particle_count : i32;
	free_particle_index : i32;
	begin_callback : EmitterBeginCallback;
	finish_callback : EmitterFinishCallback;
}

@ForwardDeclare(ChunkData)
ForwardChunk :: _;

@GenerateComponentCode
Dummy2 :: _;


/* --- ENTITIES --- */

@UniqueEntity(1, character)
Character :: struct
{
	@ComponentList(Position, SubSprite, Animation, PhysicsBody, Movement, ArcEntity)
	dummy : Dummy;
}

@UniqueEntity(50, scenic)
Cloud :: struct
{
	@ComponentList(Position, Sprite, Parallax)
	dummy : Dummy;
}

@UniqueEntity(1024, ground)
Ground :: struct
{
	@ComponentList(Position, PhysicsBody)
	dummy : Dummy;
}

@GenerateEntityCode
Dummy3 :: _;

Entity :: struct
{
	entity_id : i32;
	name : char[20];
	generalised_type : GeneralisedEntityType;
	
	unique_entity : *void;
	type : EntityType;
	
	flags : EntityFlags;
	components : *void[COMPONENT_MAX];
	active_chunk : *ChunkData;
}


/* --- WORLD DATA --- */

@ForwardDeclare(Cell)
ForwardCell :: _;

CellMaterial :: struct
{
	id : i32;
	parent_cell : *Cell;
	material_type : CellMaterialType;
	flags : CellFlags;
	
	mass : f32; // TODO: Extract these out into material lookup data
	restitution : f32;
	max_height : i32;
	
	position : v2;
	velocity : v2;
	
	is_material_dynamic : b8;
	has_been_updated : b8;
}

@ForwardDeclare(CellChunk)
ForwardCellChunk :: _;

Cell :: struct
{
	parent_cell_chunk : *CellChunk;
	x_index : i32;
	y_index : i32;
	
	material : *CellMaterial;
}

CellChunk :: struct
{
	parent_chunk : *ChunkData;
	x_index : i32;
	y_index : i32;
	
	cells : Cell[CELL_CHUNK_SIZE][CELL_CHUNK_SIZE];
	
	texture : Ts2dTexture;
}

ChunkData :: struct
{
	is_valid : b8;
	entity_ids : i32[MAX_ENTITIES_PER_CHUNK];
	entity_count : i32;
	x_index : i32;
	y_index : i32;
	
	cell_chunks : CellChunk[CHUNK_SIZE / CELL_CHUNK_SIZE][CHUNK_SIZE / CELL_CHUNK_SIZE];
	
	cell_materials : CellMaterial[CHUNK_SIZE * CHUNK_SIZE];
	cell_material_count : i32;
	free_cell_material_id : i32;
	
	dynamic_cell_materials : *CellMaterial[MAX_DYNAMIC_CELLS];
	dynamic_cell_material_count : i32;
}

WorldData :: struct
{
	elapsed_world_time : f32;
	
	active_chunks : ChunkData[MAX_WORLD_CHUNKS];
	active_chunk_count : i32;
	floating_chunk : ChunkData;
	
	@GenerateUniqueEntityArrays
	entities : Entity[MAX_ACTIVE_ENTITIES];
	entity_count : i32;
	free_entity_index : i32;
	
	entity_components : ComponentSet;
}