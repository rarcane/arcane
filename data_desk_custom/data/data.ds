/* --- CONSTANTS --- */

MAX_ENTITIES_PER_CHUNK :: 256
MAX_ACTIVE_ENTITIES :: 1024
MAX_OVERLAPPING_COLLIDERS :: 50
MAX_ENTITY_REFERENCES :: 10
MAX_SUB_COLLIDERS :: 3
MAX_STORAGE_SIZE :: 30
MAX_PARTICLE_AMOUNT :: 300
MAX_WORLD_CHUNKS :: 128
CHUNK_SIZE :: 200
MAX_PIXEL_CLUSTER_LENGTH :: 64


/* --- ENUMS --- */

GeneralisedEntityType :: enum
{
    undefined,
	character,
	monster,
	animal,
	item,
	storage,
	resource,
	scenic,
	ground,
	pixel_object,
}


/* --- FLAGS --- */

EntityFlags :: flags
{
	no_delete,
}

ColliderFlags :: flags
{
	ground,
	player,
	entity,
	item,
	trigger,
}

AnimationFlags :: flags
{
	playing,
	reversing,
	repeat,
}

ParticleEmitterFlags :: flags
{
	repeat,
}

PixelFlags :: flags
{
	apply_gravity,
}

@ForwardDeclare(Entity)
ForwardEntity :: _;


/* --- COMPONENTS --- */

@Component
Position :: struct
{
	position : v2;
}

@Component
Sprite :: struct
{
	sprite_data : SpriteData;
	@Editable
	is_flipped : b8;
	is_background_sprite : b8; // Temp solution
}

@Component
SubSprite :: struct
{
	sub_sprites : SpriteData[MAX_SUB_SPRITES];
	sub_sprite_count : i32;
	is_flipped : b8;
}

@Component
Animation :: struct
{
	flags : AnimationFlags;
	current_frame : i32;
	interval_mult : f32;
	frame_start_time : f32;
}

@Component
Collider :: struct
{
	shape : Shape;
	flags : ColliderFlags;
}

@Component
Velocity :: struct
{
	velocity : v2;
	ideal_velocity : v2;
	acceleration : v2; // You'd have this be dynamic depending on the alpha of the ideal/current velocity to have a multi-phased acceleration function.
	acceleration_mult : v2;
	previous_friction : f32;
	collide_against : b8;
}

@Component
Physics :: struct
{
	friction_mult : f32;
	bounce_mult : f32;
}

@Component
Movement :: struct
{
	axis_x : f32;
	move_speed : f32;
	move_speed_mult : f32;
}

@Component
ArcEntity :: struct
{
	entity_type : ArcEntityType;
	current_general_state : *char;
	current_animation_state : AnimationStateType;
}

@Component
Item :: struct
{
	item_type : ItemType;
	stack_size : i32;
}

@Component
Trigger :: struct
{
	enter_trigger_callback : TriggerCallback;
	exit_trigger_callback : TriggerCallback;
	previous_overlaps : OverlappedColliderInfo[MAX_OVERLAPPING_COLLIDERS];
	previous_overlaps_count : i32;
	trigger_against : b8;
}

@Component
Storage :: struct
{
	storage_size : i32;
	items : *ItemComponent[MAX_STORAGE_SIZE];
}

@Component
Parallax :: struct
{
	parallax_amount : v2;
	desired_position : v2;
}

@Component
ParticleEmitter :: struct
{
	life_time : f32;
	start_time : f32;
	flags : ParticleEmitterFlags;
	particles : Particle[MAX_PARTICLE_AMOUNT]; // Need to put this somewhere else?
	particle_count : i32;
	free_particle_index : i32;
	begin_callback : EmitterBeginCallback;
	finish_callback : EmitterFinishCallback;
}

@ForwardDeclare(ChunkData)
ForwardChunk :: _;

@GenerateComponentCode
Dummy2 :: _;


/* --- ENTITIES --- */

@UniqueEntity(1, character)
Character :: struct
{
	@ComponentList(Position, SubSprite, Animation, Collider, Physics, Velocity, Movement, ArcEntity)
	dummy : Dummy;
}

@UniqueEntity(50, scenic)
Cloud :: struct
{
	@ComponentList(Position, Sprite, Parallax)
	dummy : Dummy;
}

@UniqueEntity(1024, ground)
Ground :: struct
{
	@ComponentList(Position, Collider, Physics)
	dummy : Dummy;
}

Pixel :: struct
{
	position : v2;
	colour : v4;
}

@UniqueEntity(1024, pixel_object)
FloatingPixel :: struct
{
	@ComponentList(Position)
	dummy : Dummy;
	
	flags : PixelFlags;
	
	colour : v4;
	
	mass : f32;
	velocity : v2;
	restitution : f32;
}

@UniqueEntity(1024, pixel_object)
PixelCluster :: struct
{
	@ComponentList(Position)
	dummy : Dummy;
	
	flags : PixelFlags;
	
	pixels : Pixel[MAX_PIXEL_CLUSTER_LENGTH * MAX_PIXEL_CLUSTER_LENGTH];
	texture : Ts2dTexture;
	
	mass : f32;
	velocity : v2;
	restitution : f32;
}

@GenerateEntityCode
Dummy3 :: _;

Entity :: struct
{
	entity_id : i32;
	name : char[20];
	generalised_type : GeneralisedEntityType;
	
	unique_entity : *void;
	type : EntityType;
	
	flags : EntityFlags;
	components : *void[COMPONENT_MAX];
	active_chunk : *ChunkData;
}


/* --- WORLD DATA --- */

ChunkData :: struct
{
	is_valid : b8;
	entity_ids : i32[MAX_ENTITIES_PER_CHUNK];
	entity_count : i32;
	x_index : i32;
	y_index : i32;
}

WorldData :: struct
{
	elapsed_world_time : f32;
	
	active_chunks : ChunkData[MAX_WORLD_CHUNKS];
	active_chunk_count : i32;
	floating_chunk : ChunkData;
	
	@GenerateUniqueEntityArrays
	entities : Entity[MAX_ACTIVE_ENTITIES];
	entity_count : i32;
	free_entity_index : i32;
	
	entity_components : ComponentSet;
}