/* --- DEFINES --- */

@Define
MAX_ENTITIES_PER_CHUNK :: 128;
@Define
MAX_ACTIVE_ENTITIES :: 1024;
@Define
MAX_OVERLAPPING_COLLIDERS :: 50;
@Define
MAX_ENTITY_REFERENCES :: 10;
@Define
MAX_SUB_COLLIDERS :: 3;
@Define
MAX_STORAGE_SIZE :: 30;
@Define
MAX_PARTICLE_AMOUNT :: 300;
@Define
MAX_WORLD_CHUNKS :: 128;
@Define
CHUNK_SIZE :: 200;

/* --- ENUMS --- */

EntityType :: enum
{
    undefined,
	character,
	monster,
	animal,
	item,
	storage,
	resource,
	scenic,
	ground,
}

/* --- FLAGS --- */

EntityFlags :: flags
{
	no_delete,
}

ColliderFlags :: flags
{
	ground,
	player,
	entity,
	item,
	trigger,
}

AnimationFlags :: flags
{
	playing,
	reversing,
	repeat,
}

ParticleEmitterFlags :: flags
{
	repeat,
}

/* --- ECS --- */

@ForwardDeclare(Entity)
ForwardEntity :: _;

@Component
Position :: struct
{
	position : v2;
}

@Component
Sprite :: struct
{
	sprite_data : SpriteData;
	@Editable
	is_flipped : b8;
	is_background_sprite : b8; // Temp solution
}

@Component
SubSprite :: struct
{
	sub_sprites : SpriteData[MAX_SUB_SPRITES];
	sub_sprite_count : i32;
	is_flipped : b8;
}

@Component
Animation :: struct
{
	flags : AnimationFlags;
	current_frame : i32;
	interval_mult : f32;
	frame_start_time : f32;
}

@Component
Collider :: struct
{
	shape : Shape;
	flags : ColliderFlags;
}

@Component
Velocity :: struct
{
	velocity : v2;
	ideal_velocity : v2;
	acceleration : v2; // You'd have this be dynamic depending on the alpha of the ideal/current velocity to have a multi-phased acceleration function.
	acceleration_mult : v2;
	previous_friction : f32;
	collide_against : b8;
}

@Component
Physics :: struct
{
	friction_mult : f32;
	bounce_mult : f32;
}

@Component
Movement :: struct
{
	axis_x : f32;
	move_speed : f32;
	move_speed_mult : f32;
}

@Component
ArcEntity :: struct
{
	entity_type : ArcEntityType;
	current_general_state : *char;
	current_animation_state : AnimationStateType;
}

@Component
Item :: struct
{
	item_type : ItemType;
	stack_size : i32;
}

@Component
Trigger :: struct
{
	enter_trigger_callback : TriggerCallback;
	exit_trigger_callback : TriggerCallback;
	previous_overlaps : OverlappedColliderInfo[MAX_OVERLAPPING_COLLIDERS];
	previous_overlaps_count : i32;
	trigger_against : b8;
}

@Component
Storage :: struct
{
	storage_size : i32;
	items : *ItemComponent[MAX_STORAGE_SIZE];
}

@Component
Parallax :: struct
{
	parallax_amount : v2;
	desired_position : v2;
}

@Component
ParticleEmitter :: struct
{
	life_time : f32;
	start_time : f32;
	flags : ParticleEmitterFlags;
	particles : Particle[MAX_PARTICLE_AMOUNT]; // Need to put this somewhere else?
	particle_count : i32;
	free_particle_index : i32;
	begin_callback : EmitterBeginCallback;
	finish_callback : EmitterFinishCallback;
}

@ForwardDeclare(ChunkData)
ForwardChunk :: _;

@GenerateComponentList // Tag is used to generate all of the component data.
Entity :: struct
{
	entity_id : i32;
	name : char[20];
	type : EntityType;
	flags : EntityFlags;
	components : *void[COMPONENT_MAX];
	active_chunk : *ChunkData;
}

/* --- WORLD DATA --- */

ChunkData :: struct
{
	is_valid : b8;
	entity_ids : i32[MAX_ENTITIES_PER_CHUNK];
	entity_count : i32;
	x_index : i32;
	y_index : i32;
}

WorldData :: struct
{
	elapsed_world_time : f32;
	
	active_chunks : ChunkData[MAX_WORLD_CHUNKS];
	active_chunk_count : i32;
	floating_chunk : ChunkData;
	
	entities : Entity[MAX_ACTIVE_ENTITIES];
	entity_count : i32;
	free_entity_index : i32;
	entity_components : ComponentSet;
}