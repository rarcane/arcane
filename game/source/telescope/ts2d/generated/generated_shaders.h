typedef enum TsOpenGLShaderType TsOpenGLShaderType;
enum TsOpenGLShaderType
{
TS_OPENGL_SHADER_background,
TS_OPENGL_SHADER_bloom_filter,
TS_OPENGL_SHADER_fbo_reflection,
TS_OPENGL_SHADER_filled_rect,
TS_OPENGL_SHADER_line,
TS_OPENGL_SHADER_model_sprite,
TS_OPENGL_SHADER_post_process,
TS_OPENGL_SHADER_rect,
TS_OPENGL_SHADER_reflection,
TS_OPENGL_SHADER_reflective_rect,
TS_OPENGL_SHADER_shadow,
TS_OPENGL_SHADER_text,
TS_OPENGL_SHADER_texture,
TS_OPENGL_SHADER_texture_reflection,
TS_OPENGL_SHADER_world,
TS_OPENGL_SHADER_world_tile,
TS_OPENGL_SHADER_fbo,
TS_OPENGL_SHADER_gaussian_blur,
TS_OPENGL_SHADER_MAX,
};

#define TS_OPENGL_SHADER_INPUT_MAX 16
#define TS_OPENGL_SHADER_OUTPUT_MAX 16
global struct
{
char *name;
TsOpenGLShaderInput inputs[TS_OPENGL_SHADER_INPUT_MAX];
u32 input_count;
TsOpenGLShaderOutput outputs[TS_OPENGL_SHADER_OUTPUT_MAX];
u32 output_count;
char *vert;
char *frag;
}
_ts_render_global_opengl_shaders[] = {
{
"Background",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position.xy = screen_position.xy * 2 - 1;\n"
"    frag_uv = vert_position;\n"
"    gl_Position = screen_position;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"\n"
"void main()\n"
"{\n"
"    color = texture(tex, frag_uv);\n"
"    color.xyz /= color.a;\n"
"    if(color.a <= 0)\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"Bloom Filter",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    \n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position.xy = screen_position.xy * 2 - 1;\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position.xy;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform sampler2D foreground_tex;\n"
"\n"
"void main()\n"
"{\n"
"    vec4 foreground_color = texture(foreground_tex, frag_uv);\n"
"    color = texture(tex, frag_uv);\n"
"    float brightness = (0.299*color.r + 0.587*color.g + 0.114*color.b);\n"
"    if(foreground_color.a < 0.1)\n"
"    {\n"
"        brightness -= 0.4;\n"
"    }\n"
"    color *= brightness * 1.4;\n"
"}\n"
"",
},
{
"Reflection FBO",
{
0},
0,
{
{ 1, "reflection", },
{ 0, "color", },
},
2,
"#version 330 core\n"
"\n"
"\n"
"out vec2 frag_uv;\n"
"out vec2 frag_position;\n"
"uniform vec4 destination;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    \n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    frag_position = screen_position.xy;\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position.xy;\n"
"}\n"
"\n"
"",
"#version 330 core\n"
"\n"
"\n"
"in vec2 frag_uv;\n"
"in vec2 frag_position;\n"
"out vec4 color;\n"
"out vec4 reflection;\n"
"uniform vec2 uv_offset;\n"
"uniform vec2 uv_range;\n"
"uniform vec4 destination;\n"
"uniform vec2 scale;\n"
"uniform float opacity;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 pixel = (uv_offset + (frag_uv * uv_range));\n"
"    vec2 sample_uv = floor(pixel) + vec2(0.5, 0.5);\n"
"    \n"
"    sample_uv.x += 1.0 - clamp((1.0 - fract(pixel.x)) * scale.x, 0.0, 1.0);\n"
"    sample_uv.y += 1.0 - clamp((1.0 - fract(pixel.y)) * scale.y, 0.0, 1.0);\n"
"    \n"
"    color = texture(tex, sample_uv / tex_resolution);\n"
"    color.xyz /= color.a;\n"
"    if(color.a > 0)\n"
"    {\n"
"        color *= opacity;\n"
"        reflection = vec4(0, 0, 0, color.a);\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"\n"
"",
},
{
"Filled Rect Batch",
{
{ 4, "vert_color11", },
{ 3, "vert_color10", },
{ 2, "vert_color01", },
{ 1, "vert_color00", },
{ 0, "vert_rect_data", },
},
5,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"\n"
"in vec4 vert_rect_data;\n"
"in vec4 vert_color00;\n"
"in vec4 vert_color01;\n"
"in vec4 vert_color10;\n"
"in vec4 vert_color11;\n"
"out vec4 rect_color;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    vec4 destination = vert_rect_data;\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    gl_Position = screen_position;\n"
"    \n"
"    vec4 colors[] = vec4[](vert_color00, vert_color01, vert_color10, vert_color11);\n"
"    \n"
"    rect_color = colors[gl_VertexID];\n"
"}\n"
"\n"
"",
"#version 330 core\n"
"\n"
"\n"
"in vec4 rect_color;\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"    color = rect_color;\n"
"}\n"
"\n"
"",
},
{
"Line Batch",
{
{ 2, "vert_color_data", },
{ 1, "vert_2", },
{ 0, "vert_1", },
},
3,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"in vec2 vert_1;\n"
"in vec2 vert_2;\n"
"in vec4 vert_color;\n"
"out vec4 frag_color_data;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](vert_1, vert_2);\n"
"    frag_color_data = vert_color;\n"
"    vec4 screen_position = vec4(vertices[gl_VertexID], 0, 1);\n"
"    gl_Position = screen_position;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec4 frag_color_data;\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"    color = frag_color_data;\n"
"}\n"
"",
},
{
"Model Sprite",
{
{ 4, "vert_bone_weights_", },
{ 3, "vert_bone_indices_", },
{ 2, "vert_normal_", },
{ 1, "vert_uv_", },
{ 0, "vert_position_", },
},
5,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"\n"
"in vec3 vert_position_;\n"
"in vec2 vert_uv_;\n"
"in vec3 vert_normal_;\n"
"in ivec4 vert_bone_indices_;\n"
"in vec4 vert_bone_weights_;\n"
"\n"
"out vec3 frag_position;\n"
"out vec3 frag_normal;\n"
"\n"
"uniform mat3 model_transform;\n"
"uniform mat4 view_projection;\n"
"uniform mat4 bone_transform[32];\n"
"uniform int transform_with_bones;\n"
"uniform vec3 origin_shift;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 vert_position = vert_position_;\n"
"    vec2 vert_uv = vert_uv_;\n"
"    vec3 vert_normal = vert_normal_;\n"
"    ivec4 vert_bone_indices = vert_bone_indices_;\n"
"    vec4 vert_bone_weights = vert_bone_weights_;\n"
"    \n"
"    vec4 model_position = vec4(vert_position + origin_shift, 1);\n"
"    if(transform_with_bones != 0 && vert_bone_indices.x != -1)\n"
"    {\n"
"        int bone_index_1 = vert_bone_indices.x;\n"
"        int bone_index_2 = vert_bone_indices.y;\n"
"        int bone_index_3 = vert_bone_indices.z;\n"
"        int bone_index_4 = vert_bone_indices.w;\n"
"        \n"
"        float bone_weight_1 = vert_bone_weights.x;\n"
"        float bone_weight_2 = vert_bone_weights.y;\n"
"        float bone_weight_3 = vert_bone_weights.z;\n"
"        float bone_weight_4 = vert_bone_weights.w;\n"
"        \n"
"		model_position =\n"
"            ((bone_transform[bone_index_1] * model_position * bone_weight_1) +\n"
"             (bone_transform[bone_index_2] * model_position * bone_weight_2) +\n"
"             (bone_transform[bone_index_3] * model_position * bone_weight_3) +\n"
"             (bone_transform[bone_index_4] * model_position * bone_weight_4));\n"
"    }\n"
"    \n"
"    vec3 vertex_position = model_transform * model_position.xyz;\n"
"    vec4 world_space_position = vec4(vertex_position.x, vertex_position.y, vertex_position.z, 1);\n"
"    vec4 clip_space_position = view_projection * world_space_position;\n"
"    gl_Position = clip_space_position;\n"
"    frag_position = vertex_position;\n"
"    \n"
"	frag_normal = normalize(model_transform * vert_normal);\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"\n"
"in vec3 frag_position;\n"
"in vec3 frag_normal;\n"
"\n"
"out vec4 color;\n"
"\n"
"uniform vec3 shadow_vector;\n"
"\n"
"void main()\n"
"{\n"
"    // NOTE(rjf): Calculate diffuse lighting.\n"
"    float diffuse_factor = 1;\n"
"    {\n"
"        diffuse_factor = dot(shadow_vector, frag_normal);\n"
"        diffuse_factor *= diffuse_factor;\n"
"    }\n"
"    \n"
"    color = vec4(diffuse_factor, diffuse_factor, diffuse_factor, 1);\n"
"}\n"
"",
},
{
"Post Process",
{
{ 0, "vert_position", },
},
1,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"							 vec2(0, 0),\n"
"							 vec2(0, 1),\n"
"							 vec2(1, 0),\n"
"							 vec2(1, 1)\n"
"							 );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position.xy = screen_position.xy * 2 - 1;\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position.xy;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform float grayscale;\n"
"uniform vec2 resolution;\n"
"uniform vec2 camera_pos;\n"
"uniform float camera_zoom;\n"
"\n"
"#define MAX_GROUND_VERTICES 64\n"
"uniform vec2 ground_vertices[MAX_GROUND_VERTICES];\n"
"uniform int ground_vertex_count;\n"
"\n"
"uniform float scale;\n"
"uniform float vor_step;\n"
"uniform float band_height;\n"
"\n"
"float random(vec2 st)\n"
"{\n"
"    return fract(sin(dot(st.xy,\n"
"                         vec2(12.9898,78.233))) * 43758.5453123);\n"
"}\n"
"\n"
"vec2 random2(vec2 p)\n"
"{\n"
"    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n"
"}\n"
"\n"
"vec3 ColorRock(float alpha, vec3 highlight, vec3 body, vec3 outline)\n"
"{\n"
"    if (alpha == 1.)\n"
"    {\n"
"		return highlight;\n"
"    }\n"
"    else if (alpha == .5)\n"
"    {\n"
"        return body;\n"
"    }\n"
"    else if (alpha == .25)\n"
"    {\n"
"        return outline;\n"
"    }\n"
"    \n"
"    return vec3(0.);\n"
"}\n"
"\n"
"float Voronoi(in vec2 st, in float scale, out vec2 min_abs_point, out vec2 id, out float dp)\n"
"{\n"
"	st *= scale;\n"
"	vec2 i_st = floor(st);\n"
"	vec2 f_st = fract(st);\n"
"	\n"
"	vec2 mb;\n"
"	vec2 mr;\n"
"	float md = 8.;\n"
"	\n"
"	for (int y = -1; y <= 1; y++)\n"
"		for (int x = -1; x <= 1; x++)\n"
"	{\n"
"		vec2 b = vec2(x, y);\n"
"		vec2 r = vec2(b) + random2(i_st+b)-f_st;\n"
"		float d = dot(r,r);\n"
"		\n"
"		if(d < md)\n"
"		{\n"
"			md = d;\n"
"			mr = r;\n"
"			mb = b;\n"
"			\n"
"			min_abs_point = random2(i_st + b) + b + i_st;\n"
"			dp = dot(normalize(r), -vec2(0.0, 1.0)) * 0.5 + 0.5;\n"
"		}\n"
"	}\n"
"	\n"
"	md = 8.;\n"
"	\n"
"	for(int y = -2; y <= 2; y++)\n"
"		for (int x = -2; x <= 2; x++)\n"
"	{\n"
"		vec2 b = mb + vec2(x, y);\n"
"		vec2 r = vec2(b) + random2(i_st+b) - f_st;\n"
"		float d = dot(.5*(mr+r), normalize(r-mr));\n"
"		\n"
"		md = min(md, d);\n"
"	}\n"
"	\n"
"	id = random2(i_st);\n"
"    \n"
"    return md;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec4 frag_color = texture(tex, frag_uv);\n"
"    frag_color.xyz /= frag_color.a;\n"
"    \n"
"    float brightness = (0.299*frag_color.r + 0.587*frag_color.g + 0.114*frag_color.b);\n"
"    frag_color.r += (brightness - frag_color.r) * grayscale;\n"
"    frag_color.g += (brightness - frag_color.g) * grayscale;\n"
"    frag_color.b += (brightness - frag_color.b) * grayscale;\n"
"    \n"
"	vec2 st = frag_uv * resolution;\n"
"	\n"
"	st = st - resolution / 2.;\n"
"	st += vec2(camera_pos.x * camera_zoom, -camera_pos.y * camera_zoom);\n"
"	\n"
"	st = floor(st / camera_zoom);\n"
"	\n"
"	vec2 current_point;\n"
"	vec2 id;\n"
"	float dp;\n"
"	float vor = Voronoi(st, scale, current_point, id, dp);\n"
"	\n"
"	bool is_below = false;\n"
"	bool is_pixel_above = false;\n"
"	\n"
"	float pixel_depth = 0.;\n"
"	const float buffer_value = 0.5;\n"
"	\n"
"	for (int i = 0; i < MAX_GROUND_VERTICES - 1; i++)\n"
"	{\n"
"		if (i == ground_vertex_count)\n"
"			break;\n"
"		\n"
"		vec2 vert1 = ground_vertices[i] * scale;\n"
"		vec2 vert2 = ground_vertices[i + 1] * scale;\n"
"		vec2 diff = vert2 - vert1;\n"
"		\n"
"		// Is the current point between the two vertices?\n"
"		if (current_point.x >= vert1.x && current_point.x < vert2.x)\n"
"		{\n"
"			float y = -diff.y / diff.x * (vert1.x - current_point.x);\n"
"			\n"
"			if (current_point.y - buffer_value < y + vert1.y)\n"
"			{\n"
"				is_below = true;\n"
"				\n"
"				float y_above = -diff.y / diff.x * (vert1.x - st.x * scale);\n"
"				if (st.y * scale > y_above + vert1.y + buffer_value)\n"
"				{\n"
"					is_pixel_above = true;\n"
"				}\n"
"				\n"
"				pixel_depth = y + vert1.y - current_point.y - buffer_value;\n"
"				\n"
"				break;\n"
"			}\n"
"		}\n"
"	}\n"
"	\n"
"	vec2 current_point1;\n"
"    vec2 id1;\n"
"    float dp1;\n"
"    vec2 offset = vec2(-0.400,0.260);\n"
"    float vor1 = Voronoi(st + offset / scale, scale, current_point1, id1, dp1);\n"
"	\n"
"	vec3 colors[6];\n"
"    colors[0] = vec3(121./255., 87./255., 70./255.);\n"
"    colors[1] = vec3(80./255., 58./255., 51./255.);\n"
"    colors[2] = vec3(50./255., 33./255., 35./255.);\n"
"    colors[3] = vec3(29./255., 19./255., 21./255.);\n"
"    colors[4] = vec3(11./255., 11./255., 12./255.);\n"
"    colors[5] = vec3(5./255., 5./255., 5./255.);\n"
"	\n"
"	float alpha = step(vor_step, vor);\n"
"    // highlight\n"
"    if (current_point == current_point1)\n"
"    {\n"
"        alpha *= 0.5;\n"
"        // color = colors[1];\n"
"    }\n"
"    // fill in cracks\n"
"    if (alpha == 0.0 && !is_pixel_above)\n"
"    {\n"
"        alpha = 0.25;\n"
"    }\n"
"	\n"
"    vec3 rock_color = vec3(0.);\n"
"    if (is_below)\n"
"    {\n"
"        rock_color = colors[5];\n"
"		\n"
"		if (pixel_depth / scale < band_height / 2.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[0], colors[1], colors[2]);\n"
"			if (random(current_point) < 0.25)\n"
"				rock_color = ColorRock(alpha, vec3(155./255., 117./255., 82./255.), colors[1], colors[2]);\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 1.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[0], colors[1], colors[2]);\n"
"			if (random(current_point) < 0.5)\n"
"				rock_color = ColorRock(alpha, colors[1], colors[2], colors[2]);\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 2.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[1], colors[2], colors[3]);\n"
"			if (random(current_point) < .25)\n"
"				rock_color = ColorRock(alpha, colors[2], colors[2], colors[3]);\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 3.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[1], colors[2], colors[3]);\n"
"			if (random(current_point) < 0.25)\n"
"				rock_color = ColorRock(alpha, colors[2], colors[3], colors[3]);\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 4.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[2], colors[3], colors[4]);\n"
"			if (random(current_point) < 0.25)\n"
"				rock_color = ColorRock(alpha, colors[2], colors[2], colors[4]);\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 5.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[2], colors[3], colors[4]);\n"
"			if (random(current_point) < 0.5)\n"
"				rock_color = ColorRock(alpha, colors[3], colors[4], colors[4]);\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 6.)\n"
"		{\n"
"			// this was causing a weird bug?\n"
"			// color = ColorRock(alpha, colors[4], colors[4], colors[5]);\n"
"			\n"
"			if (alpha == 1.)\n"
"			{\n"
"				rock_color = colors[4];\n"
"				if (random(current_point) < 0.5)\n"
"					rock_color = colors[3];\n"
"			}\n"
"			else if (alpha == .5)\n"
"			{\n"
"				rock_color = colors[4];\n"
"			}\n"
"			else if (alpha == .25)\n"
"			{\n"
"				rock_color = colors[5];\n"
"			}\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 7.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[4], colors[4], colors[5]);\n"
"			if (random(current_point) < .5)\n"
"				rock_color = colors[5];\n"
"		}\n"
"		else if (pixel_depth / scale < band_height * 8.)\n"
"		{\n"
"			rock_color = ColorRock(alpha, colors[4], colors[5], colors[5]);\n"
"			if (random(current_point) < 0.75)\n"
"				rock_color = colors[5];\n"
"		}\n"
"    }\n"
"	\n"
"	if (rock_color == vec3(0.))\n"
"	{\n"
"		if(frag_color.a > 0)\n"
"		{\n"
"			color = frag_color;\n"
"		}\n"
"		else\n"
"		{\n"
"			discard;\n"
"		}\n"
"	}\n"
"	else\n"
"	{\n"
"		color = vec4(rock_color.rgb, 1.);\n"
"	}\n"
"	\n"
"	/*\n"
"		for (int i = 0; i < MAX_GROUND_VERTICES; i++)\n"
"		{\n"
"			if (i == ground_vertex_count)\n"
"				break;\n"
"			color.rgb += vec3(1.-step(2., length(ground_vertices[i] - st)));\n"
"		}\n"
"	 */\n"
"}\n"
"",
},
{
"Rectangle Batch",
{
{ 1, "vert_color_data", },
{ 0, "vert_rect_data", },
},
2,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"in vec4 vert_rect_data;\n"
"in vec4 vert_color_data;\n"
"out vec4 frag_color_data;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 1),\n"
"        vec2(1, 0)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    vec4 destination = vert_rect_data;\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    gl_Position = screen_position;\n"
"    frag_color_data = vert_color_data;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec4 frag_color_data;\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"    color = frag_color_data;\n"
"}\n"
"",
},
{
"Reflection Pass",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"void main()\n"
"{\n"
"    vec4 vertices[] = vec4[](vec4(0, 0, 0, 1),\n"
"                             vec4(0, 1, 0, 1),\n"
"                             vec4(1, 0, 0, 1),\n"
"                             vec4(1, 1, 0, 1));\n"
"    frag_uv = vertices[gl_VertexID].xy;\n"
"    gl_Position = vertices[gl_VertexID] * 2 - 1;\n"
"}\n"
"\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform sampler2D reflection_color_tex;\n"
"uniform sampler2D reflection_data_tex;\n"
"uniform vec2 render_resolution;\n"
"uniform float wave_position;\n"
"void main()\n"
"{\n"
"    vec4 reflection_color = texture(reflection_color_tex, frag_uv);\n"
"    float reflection_amount = reflection_color.a;\n"
"    if(reflection_amount > 0.01)\n"
"    {\n"
"        vec4 reflection_data = texture(reflection_data_tex, frag_uv);\n"
"        float distortion_amount = reflection_data.y;\n"
"        float distortion_by_time_factor = reflection_data.z;\n"
"        vec4 reflection = vec4(0, 0, 0, 0);\n"
"        \n"
"        float kernel[33] = float[](0.000035, 0.000091, 0.000225, 0.00052,\n"
"                                   0.001131, 0.002312, 0.004442, 0.008019,\n"
"                                   0.013604, 0.021686, 0.032486, 0.04573,\n"
"                                   0.060495, 0.075201, 0.087848, 0.096435,\n"
"                                   0.09948, 0.096435, 0.087848, 0.075201,\n"
"                                   0.060495, 0.04573, 0.032486, 0.021686,\n"
"                                   0.013604, 0.008019, 0.004442, 0.002312,\n"
"                                   0.001131, 0.00052, 0.000225, 0.000091,\n"
"                                   0.000035);\n"
"        \n"
"        float adjusted_wave_position = wave_position * distortion_by_time_factor;\n"
"        vec2 sample_offset;\n"
"        for(int i = 0; i < 33; ++i)\n"
"        {\n"
"            sample_offset.y = (float(i) - 16.5) / render_resolution.y;\n"
"            sample_offset.x = 6.f * sin(adjusted_wave_position + float(i)*0.5) / render_resolution.x;\n"
"            reflection += texture(tex, vec2(frag_uv.x + sample_offset.x, frag_uv.y + reflection_data.x * 2 + sample_offset.y)) * kernel[i];\n"
"        }\n"
"        \n"
"        float t_reflection = reflection_data.x * render_resolution.y / 512.0;\n"
"        color = (1 - t_reflection) * reflection + t_reflection * reflection_color;\n"
"        color *= reflection_amount;\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"\n"
"",
},
{
"Reflective Rectangle Batch",
{
{ 2, "vert_reflection_data", },
{ 1, "vert_color_data", },
{ 0, "vert_rect_data", },
},
3,
{
{ 1, "reflection", },
{ 0, "color", },
},
2,
"#version 330 core\n"
"\n"
"in vec4 vert_rect_data;\n"
"in vec4 vert_color_data;\n"
"in vec4 vert_reflection_data;\n"
"out float frag_clip_space_y;\n"
"out float frag_rect_top_clip_space_y;\n"
"out vec4 frag_color_data;\n"
"out vec4 frag_reflection_data;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    vec4 destination = vert_rect_data;\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    gl_Position = screen_position;\n"
"    frag_clip_space_y = -gl_Position.y;\n"
"    frag_rect_top_clip_space_y = -destination.y;\n"
"    frag_color_data = vert_color_data;\n"
"    frag_reflection_data = vert_reflection_data;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in float frag_clip_space_y;\n"
"in float frag_rect_top_clip_space_y;\n"
"in vec4 frag_color_data;\n"
"in vec4 frag_reflection_data;\n"
"out vec4 color;\n"
"out vec4 reflection;\n"
"void main()\n"
"{\n"
"    float distance_from_water_top = frag_clip_space_y - frag_rect_top_clip_space_y;\n"
"    color = frag_color_data;\n"
"    reflection.x = distance_from_water_top / 2;\n"
"    reflection.y = frag_reflection_data.x;\n"
"    reflection.z = frag_reflection_data.y;\n"
"    reflection.w = 1;\n"
"}\n"
"",
},
{
"Shadow",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"out vec2 frag_position;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position = screen_position * 2 - 1;\n"
"    frag_position = screen_position.xy;\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position.xy;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec2 frag_position;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"uniform vec2 light_vector;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 pixel = frag_uv * tex_resolution;\n"
"    vec2 sample_uv = pixel;\n"
"    vec4 frag_color = texture(tex, frag_uv);\n"
"    \n"
"    float shadow_value = 0;\n"
"    if(frag_color.a > 0)\n"
"    {\n"
"        for(int i = 0; i < 16; ++i)\n"
"        {\n"
"            vec2 sample_pos = (sample_uv + light_vector*(float(i) / 16.0));\n"
"            vec4 lookup_color = texture(tex, sample_pos / tex_resolution);\n"
"            float distance = length(sample_pos - sample_uv);\n"
"            shadow_value += 1.0 * (1 - float(i) / 16.0)*frag_color.a*(lookup_color.a/28.0);\n"
"        }\n"
"    }\n"
"    \n"
"    if(shadow_value > 0)\n"
"    {\n"
"        color = vec4(shadow_value, 0, 0, shadow_value);\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"Text",
{
{ 3, "vert_style_data", },
{ 2, "vert_color_data", },
{ 1, "vert_dest_data", },
{ 0, "vert_source_data", },
},
4,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"in vec4 vert_source_data;\n"
"in vec4 vert_dest_data;\n"
"in vec4 vert_color_data;\n"
"in vec4 vert_style_data;\n"
"out vec2 frag_uv;\n"
"out vec4 frag_color_data;\n"
"out vec4 frag_style_data;\n"
"uniform vec2 tex_resolution;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1));\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    \n"
"    vec4 source = vert_source_data;\n"
"    vec4 dest = vert_dest_data;\n"
"    vec4 color = vert_color_data;\n"
"    vec4 style = vert_style_data;\n"
"    \n"
"    screen_position.xy *= dest.zw;\n"
"    screen_position.xy += dest.xy;\n"
"    frag_color_data = color;\n"
"    frag_style_data = style;\n"
"    gl_Position = screen_position;\n"
"	frag_uv = vert_position;\n"
"    frag_uv *= source.zw / tex_resolution;\n"
"    frag_uv += source.xy / tex_resolution;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec4 frag_color_data;\n"
"in vec4 frag_style_data;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"void main()\n"
"{\n"
"    float boldness = frag_style_data.x;\n"
"    float softness = frag_style_data.y;\n"
"    vec4 text_color = frag_color_data;\n"
"    float distance = texture(tex, frag_uv).a;\n"
"    float smooth_step = smoothstep(1.0 - boldness, (1.0 - boldness) + softness, distance);\n"
"    color = text_color * smooth_step;\n"
"    color.xyz /= color.a;\n"
"    if(color.a < 0.02)\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"Texture",
{
{ 2, "vert_tint", },
{ 1, "vert_dest", },
{ 0, "vert_source", },
},
3,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"in vec4 vert_source;\n"
"in vec4 vert_dest;\n"
"in vec4 vert_tint;\n"
"out vec2 frag_uv;\n"
"out vec4 frag_source;\n"
"out vec2 frag_scale;\n"
"out vec4 frag_tint;\n"
"uniform vec2 render_resolution;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"							 vec2(0, 0),\n"
"							 vec2(0, 1),\n"
"							 vec2(1, 0),\n"
"							 vec2(1, 1)\n"
"							 );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    vec4 destination;\n"
"    destination.zw = vert_source.zw / render_resolution;\n"
"    vec2 scale = 2 * vert_dest.zw;\n"
"    destination.zw *= scale;\n"
"    destination.xy = vert_dest.xy;\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    gl_Position  = screen_position;\n"
"    frag_uv      = vert_position.xy;\n"
"    frag_uv.y    = 1 - frag_uv.y;\n"
"    frag_source  = vert_source;\n"
"    frag_scale   = vert_dest.zw;\n"
"    frag_tint    = vert_tint;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec4 frag_source;\n"
"in vec2 frag_scale;\n"
"in vec4 frag_tint;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"void main()\n"
"{\n"
"    vec2 uv_offset = frag_source.xy;\n"
"    vec2 uv_range = frag_source.zw;\n"
"    vec4 tint = frag_tint;\n"
"    vec2 scale = frag_scale;\n"
"    \n"
"    vec2 pixel = (uv_offset + (frag_uv * uv_range));\n"
"    vec2 sample_uv = floor(pixel) + vec2(0.5, 0.5);\n"
"    \n"
"    sample_uv.x += 1.0 - clamp((1.0 - fract(pixel.x)) * abs(scale.x), 0.0, 1.0);\n"
"    sample_uv.y += 1.0 - clamp((1.0 - fract(pixel.y)) * abs(scale.y), 0.0, 1.0);\n"
"    \n"
"    color = texture(tex, sample_uv / tex_resolution);\n"
"    \n"
"    if(color.a > 0)\n"
"    {\n"
"        color *= tint;\n"
"        color.xyz /= color.a;\n"
"        color.xyz = clamp(color.xyz, 0, 1);\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"Texture (Reflection)",
{
{ 2, "vert_opacity", },
{ 1, "vert_dest", },
{ 0, "vert_source", },
},
3,
{
{ 1, "reflection", },
{ 0, "color", },
},
2,
"#version 330 core\n"
"\n"
"in vec4 vert_source;\n"
"in vec4 vert_dest;\n"
"in float vert_opacity;\n"
"out vec2 frag_uv;\n"
"out vec4 frag_source;\n"
"out vec2 frag_scale;\n"
"out float frag_opacity;\n"
"uniform vec2 render_resolution;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    vec4 destination;\n"
"    destination.zw = vert_source.zw / render_resolution;\n"
"    vec2 scale = 2 * vert_dest.zw;\n"
"    destination.zw *= scale;\n"
"    destination.xy = vert_dest.xy;\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    gl_Position  = screen_position;\n"
"    frag_uv      = vert_position.xy;\n"
"    frag_uv.y    = 1 - frag_uv.y;\n"
"    frag_source  = vert_source;\n"
"    frag_scale   = vert_dest.zw;\n"
"    frag_opacity = vert_opacity;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec4 frag_source;\n"
"in vec2 frag_scale;\n"
"in float frag_opacity;\n"
"out vec4 color;\n"
"out vec4 reflection;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"void main()\n"
"{\n"
"    vec2 uv_offset = frag_source.xy;\n"
"    vec2 uv_range = frag_source.zw;\n"
"    float opacity = frag_opacity;\n"
"    vec2 scale = frag_scale;\n"
"    \n"
"    vec2 pixel = (uv_offset + (frag_uv * uv_range));\n"
"    vec2 sample_uv = floor(pixel) + vec2(0.5, 0.5);\n"
"    \n"
"    sample_uv.x += 1.0 - clamp((1.0 - fract(pixel.x)) * abs(scale.x), 0.0, 1.0);\n"
"    sample_uv.y += 1.0 - clamp((1.0 - fract(pixel.y)) * abs(scale.y), 0.0, 1.0);\n"
"    \n"
"    color = texture(tex, sample_uv / tex_resolution);\n"
"    \n"
"    if(color.a > 0)\n"
"    {\n"
"        color *= opacity;\n"
"        reflection = vec4(0, 0, 0, color.a);\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"World",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position * 2 - 1, 0, 1);\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position.xy;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"out vec4 color;\n"
"uniform sampler2D foreground_texture;\n"
"uniform sampler2D shadow_texture;\n"
"uniform float brightness;\n"
"uniform float shadow_opacity;\n"
"\n"
"struct Light\n"
"{\n"
"    vec2 position;\n"
"    vec3 color;\n"
"    float radius;\n"
"    float intensity;\n"
"};\n"
"uniform Light lights[16];\n"
"uniform int light_count;\n"
"\n"
"void main()\n"
"{\n"
"    vec4 foreground = texture(foreground_texture, frag_uv);\n"
"    float shadow_value = texture(shadow_texture, frag_uv).a * shadow_opacity;\n"
"    vec2 frag_position = gl_FragCoord.xy;\n"
"    \n"
"    color = foreground;\n"
"    color.xyz /= color.a;\n"
"    vec3 brightness_factor =\n"
"        vec3(0.02 + 0.98*clamp(brightness - shadow_value*2, 0.2, 1)\n"
"             ,   0.03 + 0.97*clamp(brightness - shadow_value*2, 0.2, 1)\n"
"             ,   0.08 + 0.92*clamp(brightness - shadow_value*2, 0.2, 1));\n"
"    vec3 diffuse_factor = brightness_factor;\n"
"    vec3 light_color_sum = vec3(0, 0, 0);\n"
"    \n"
"    // NOTE(rjf): Calculate lighting factor\n"
"    {\n"
"        for(int i = 0; i < light_count && i < 16; ++i)\n"
"        {\n"
"            vec2 diff = frag_position - lights[i].position;\n"
"            float distance2 = (diff.x*diff.x + diff.y*diff.y);\n"
"            float rad2 = lights[i].radius*lights[i].radius;\n"
"            if(distance2 < rad2)\n"
"            {\n"
"                light_color_sum += (lights[i].color * lights[i].intensity * (1 - (distance2) / rad2));\n"
"            }\n"
"        }\n"
"    }\n"
"    \n"
"    if(color.a > 0)\n"
"    {\n"
"        if(light_color_sum.r < diffuse_factor.r) light_color_sum.r = diffuse_factor.r;\n"
"        if(light_color_sum.g < diffuse_factor.g) light_color_sum.g = diffuse_factor.g;\n"
"        if(light_color_sum.b < diffuse_factor.b) light_color_sum.b = diffuse_factor.b;\n"
"        \n"
"        float brightness = (0.299*color.r + 0.587*color.g + 0.114*color.b);\n"
"        float shadow_factor = 0.3 - shadow_value;\n"
"        \n"
"        color.rgb *= light_color_sum * clamp(brightness, 0.75, 1.0);\n"
"        color.r += shadow_opacity * (1    - color.r) * shadow_factor;\n"
"        color.g += shadow_opacity * (0.95 - color.g) * shadow_factor;\n"
"        color.b += shadow_opacity * (0.92 - color.b) * shadow_factor;\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"World Tile Batch",
{
{ 2, "vert_dest", },
{ 1, "vert_source", },
},
2,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"in uvec2 vert_source;\n"
"in uvec2 vert_dest;\n"
"out vec2 frag_uv;\n"
"out vec2 frag_source;\n"
"uniform vec2 render_resolution;\n"
"void main()\n"
"{\n"
"    vec2 vertices[] =\n"
"        vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    frag_uv = vert_position.xy;\n"
"    frag_source = 16.0 * (vec2(float(vert_source.x), float(vert_source.y)) + frag_uv);\n"
"    vec2 dest_position = vec2(16.0 * float(vert_dest.x), 16.0 * float(vert_dest.y));\n"
"    vec4 destination = vec4(dest_position.x, dest_position.y, 16.0, 16.0);\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    screen_position.xy = 2 * screen_position.xy / render_resolution - 1;\n"
"    screen_position.y *= -1;\n"
"    gl_Position = screen_position;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"in vec2 frag_source;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"void main()\n"
"{\n"
"    vec2 sample_uv = frag_source;\n"
"    color = texture(tex, sample_uv / tex_resolution);\n"
"    if(color.a > 0)\n"
"    {\n"
"        color.xyz /= color.a;\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"",
},
{
"FBO",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"out vec2 frag_position;\n"
"uniform vec4 destination;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    \n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    \n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position.xy *= destination.zw;\n"
"    screen_position.xy += destination.xy;\n"
"    frag_position = screen_position.xy;\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position.xy;\n"
"}\n"
"",
"#version 330 core\n"
"\n"
"\n"
"in vec2 frag_uv;\n"
"in vec2 frag_position;\n"
"out vec4 color;\n"
"uniform vec2 uv_offset;\n"
"uniform vec2 uv_range;\n"
"uniform vec4 destination;\n"
"uniform vec2 scale;\n"
"uniform float opacity;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 pixel = (uv_offset + (frag_uv * uv_range));\n"
"    vec2 sample_uv = floor(pixel) + vec2(0.5, 0.5);\n"
"    \n"
"    sample_uv.x += 1.0 - clamp((1.0 - fract(pixel.x)) * scale.x, 0.0, 1.0);\n"
"    sample_uv.y += 1.0 - clamp((1.0 - fract(pixel.y)) * scale.y, 0.0, 1.0);\n"
"    \n"
"    color = texture(tex, sample_uv / tex_resolution);\n"
"    color.xyz /= color.a;\n"
"    if(color.a > 0)\n"
"    {\n"
"        color *= opacity;\n"
"    }\n"
"    else\n"
"    {\n"
"        discard;\n"
"    }\n"
"}\n"
"\n"
"",
},
{
"Gaussian Blur",
{
0},
0,
{
{ 0, "color", },
},
1,
"#version 330 core\n"
"\n"
"out vec2 frag_uv;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 vertices[] = vec2[](\n"
"        vec2(0, 0),\n"
"        vec2(0, 1),\n"
"        vec2(1, 0),\n"
"        vec2(1, 1)\n"
"        );\n"
"    vec2 vert_position = vertices[gl_VertexID];\n"
"    vec4 screen_position = vec4(vert_position, 0, 1);\n"
"    screen_position = 2 * screen_position - 1;\n"
"    gl_Position = screen_position;\n"
"    frag_uv = vert_position;\n"
"}\n"
"\n"
"",
"#version 330 core\n"
"\n"
"in vec2 frag_uv;\n"
"out vec4 color;\n"
"uniform sampler2D tex;\n"
"uniform vec2 tex_resolution;\n"
"uniform int radius;\n"
"uniform vec4 kernel[32];\n"
"uniform int vertical;\n"
"uniform vec4 clip;\n"
"\n"
"void main()\n"
"{\n"
"    color = vec4(0, 0, 0, 0);\n"
"    \n"
"    if(gl_FragCoord.x >= clip.x && gl_FragCoord.x <= clip.x + clip.z &&\n"
"       gl_FragCoord.y >= clip.y && gl_FragCoord.y <= clip.y + clip.w)\n"
"    {\n"
"        int first_kernel_index = (16 - radius/4);\n"
"        \n"
"        for(int i = 0; i < 2*radius/4; ++i)\n"
"        {\n"
"            if(vertical != 0)\n"
"            {\n"
"                color += texture(tex, frag_uv + vec2(0, -radius + i*4 + 0) / tex_resolution) * kernel[first_kernel_index + i].x;\n"
"                color += texture(tex, frag_uv + vec2(0, -radius + i*4 + 1) / tex_resolution) * kernel[first_kernel_index + i].y;\n"
"                color += texture(tex, frag_uv + vec2(0, -radius + i*4 + 2) / tex_resolution) * kernel[first_kernel_index + i].z;\n"
"                color += texture(tex, frag_uv + vec2(0, -radius + i*4 + 3) / tex_resolution) * kernel[first_kernel_index + i].w;\n"
"            }\n"
"            else\n"
"            {\n"
"                color += texture(tex, frag_uv + vec2(-radius + i*4 + 0, 0) / tex_resolution) * kernel[first_kernel_index + i].x;\n"
"                color += texture(tex, frag_uv + vec2(-radius + i*4 + 1, 0) / tex_resolution) * kernel[first_kernel_index + i].y;\n"
"                color += texture(tex, frag_uv + vec2(-radius + i*4 + 2, 0) / tex_resolution) * kernel[first_kernel_index + i].z;\n"
"                color += texture(tex, frag_uv + vec2(-radius + i*4 + 3, 0) / tex_resolution) * kernel[first_kernel_index + i].w;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"",
},
};

